// Importation des fichiers GeoJSON du fond de carte Promise.all([    d3.json("http://localhost:8000/eau_v2.geojson"),    d3.json("http://localhost:8000/parcs.geojson"),    d3.json("http://localhost:8000/routes_v3.geojson"),    d3.json("http://localhost:8000/patrimoine_arbore.geojson") // Load tree data here]).then(function(data) {    const eauData = data[0];    const parcsData = data[1];    const routesData = data[2];    const arbresData = data[3];    const width = document.getElementById("fond_de_carte").clientWidth;    const height = document.getElementById("fond_de_carte").clientHeight;    var projection = d3.geoMercator()        .center([7.746994, 48.583029])        .scale(800000)        .translate([width / 2, height / 2]);    var path = d3.geoPath().projection(projection);    var svgFond = d3.select("#fond_de_carte").append("svg")        .attr("width", "100%")        .attr("height", "100%");    svgFond.selectAll("path.eau_parcs")        .data(eauData.features.concat(parcsData.features))        .enter().append("path")        .attr("class", "eau_parcs")        .attr("d", path)        .attr("fill-opacity", 0.5)         .attr("fill", function(d) {            if (d.properties.type === "parc") {                return "#cdde87";            } else if (d.properties.type === "eau") {                return "#aaccff";            }        });    svgFond.selectAll("path.routes")        .data(routesData.features)        .enter().append("path")        .attr("class", "routes")        .attr("d", path)        .attr("stroke-opacity", 0.5)        .attr("stroke", "#7f7f7f")        .attr("stroke-width", 1)        .attr("fill", "none");        svgFond.selectAll("circle.arbres")        .data(arbresData.features)        .enter().append("circle")        .attr("class", "arbres")        .attr("cx", function(d) {            return projection(d.geometry.coordinates)[0];        })        .attr("cy", function(d) {            return projection(d.geometry.coordinates)[1];        })        .attr("r", 5)        .attr("fill", "green");  });// interaction de la sourislet width, height; // déclaration des variables à l'extérieur du blocvar PointsArbres =  arbresData.features.map(feature => feature.geometry.coordinates);{        const svgMouse = d3.create("svg")        .attr("viewBox", [-width / 2, -height / 2, width, height])        .style("cursor", "crosshair");    svgMouse.append("style")        .text(`circle.highlighted { stroke: orangered; fill: orangered; }`);    // x et y sont des échelles qui projettent l'espace de données sur le référentiel de pixels "non zoomé"    const x = d3.scaleLinear([0, 1], [0, 100]);    const y = d3.scaleLinear([0, 1], [0, 100]);    const delaunay = d3.Delaunay.from(PointsArbres.features, d => x(d[0]), d => y(d[1]));    const g = svgMouse.append("g");    const points = g        .selectAll("circle")        .data(arbresData.features)        .join("circle")        .attr("cx", d => x(d[0]))        .attr("cy", d => y(d[1]));    let transform;    const zoom = d3.zoom().on("zoom", e => {        g.attr("transform", (transform = e.transform));        g.style("stroke-width", 3 / Math.sqrt(transform.k));        points.attr("r", 3 / Math.sqrt(transform.k));    });    svgMouse.call(zoom)        .call(zoom.transform, d3.zoomIdentity)        .on("pointermove", event => {            const p = transform.invert(d3.pointer(event));            const i = delaunay.find(...p);            points.classed("highlighted", (_, j) => i === j);            d3.select(points.nodes()[i]).raise();        })        .node();}